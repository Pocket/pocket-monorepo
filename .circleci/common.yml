version: 2.1

orbs:
  pocket: pocket/circleci-orbs@2.2.0
  aws-cli: circleci/aws-cli@2.0.6
  aws-ecr: circleci/aws-ecr@7.3.0
  tfenv: sogaoh/orb-tfenv@0.0.1

commands:
  install_pnpm:
    steps:
      - run:
          name: Install pnpm package manager
          command: |
            corepack enable
            corepack prepare pnpm@latest-8 --activate
      - run:  
          name: Install Dependencies
          command: |
            pnpm install
  install_infrastructure_pnpm:
    steps:
      - run: 
          name: Install and setup node
          command: |
            . /home/circleci/.codebuild_shims_wrapper.sh
            nvm install
            nvm use
            npm install -g pnpm
            pnpm install        
  install_codebuild_secrets:
    steps:
      - run: 
          name: Setup our secrets from AWS Secret Manager
          command: |
            . /home/circleci/.codebuild_shims_wrapper.sh
            echo 'export SECRET_VALUE="$(aws secretsmanager get-secret-value --secret-id CodeBuild/Default --query SecretString --output text)"' >> "$BASH_ENV"
            echo 'export TERRAFORM_TOKEN="$(echo $SECRET_VALUE | jq -r '.terraform_token')"' >> "$BASH_ENV"
            echo 'export PAGERDUTY_TOKEN="$(echo $SECRET_VALUE | jq -r '.mozilla_pagerduty_token')"' >> "$BASH_ENV"
            echo 'export GITHUB_ACCESS_TOKEN="$(echo $SECRET_VALUE | jq -r '.github_access_token')"' >> "$BASH_ENV"
            echo 'export GITHUB_TOKEN="$(echo $SECRET_VALUE | jq -r '.github_access_token')"' >> "$BASH_ENV"
      - run:
          name: Save off terraform token
          command: |
            echo Setting Up Terraform Token
            rc="credentials \"app.terraform.io\" { "
            rc="${rc} token=\"$TERRAFORM_TOKEN\" "
            rc="${rc}}"
            echo "$rc" > ~/.terraformrc

jobs:

  infrastructure:
    description: Build and optionally deploy the infratructure
    parameters:
      scope:
        description: The pnpm scope to build for
        type: string
      stack-output-path:
        description: The pnpm output path
        type: string
      resource-class:
        description: The self hosted runnner to run on
        type: string
      apply:
        description: If you should apply
        type: boolean
        default: false
      dev:
        description: Whether or not its a dev build
        type: boolean
        default: false
      workspace:
        description: The terraform workspace
        type: string
    # Our self hosted runners dont support docker images, cause its not deployed in kubernetes, so we have some special steps
    machine: true
    resource_class: << parameters.resource-class >>
    steps:
      - checkout
      - run:
          name: Install tfcmt
          command: |
            curl -L https://github.com/suzuki-shunsuke/tfcmt/releases/download/v4.7.2/tfcmt_linux_amd64.tar.gz | tar xvzf - tfcmt
            mv tfcmt /home/circleci/tfcmt
            chmod a+x /home/circleci/tfcmt
      - install_infrastructure_pnpm
      - install_codebuild_secrets
      - when:
          condition: <<parameters.dev>>
          steps:
            - run:
                name: Build Dev Infra
                command: |
                  . /home/circleci/.codebuild_shims_wrapper.sh
                  nvm use
                  pnpm run --filter=<< parameters.scope >> synth:infra:dev
      - unless:
          condition: <<parameters.dev>>
          steps:
            - run:
                name: Build Prod Infra
                command: |
                  . /home/circleci/.codebuild_shims_wrapper.sh
                  nvm use
                  pnpm run --filter=<< parameters.scope >> synth:infra:prod
      - run:
          name: Setup terraform
          command: |
            . /home/circleci/.codebuild_shims_wrapper.sh
            cd << parameters.stack-output-path >>
            tfenv use
            echo 'export TF_WORKSPACE="<< parameters.workspace >>"' >> "$BASH_ENV"
            terraform init
      - when:
          condition: <<parameters.apply>>
          steps:
            - run:
                name: Terraform apply
                command: |
                  . /home/circleci/.codebuild_shims_wrapper.sh
                  cd << parameters.stack-output-path >>
                  /home/circleci/tfcmt plan -- terraform apply -auto-approve
      - unless:
          condition: <<parameters.apply>>
          steps:
            - run:
                name: Terraform plan
                command: |
                  . /home/circleci/.codebuild_shims_wrapper.sh
                  cd << parameters.stack-output-path >>
                  /home/circleci/tfcmt plan -- terraform plan

  test_integrations:
    description: Run integration tests against external services, e.g. MySQL
    parameters:
      scope:
        description: The pnpm scope to run tests for
        type: string
    docker:
      - image: *node_image
        auth:
          username: $DOCKERHUB_USERNAME
          password: $DOCKERHUB_PASSWORD
        environment:
          NODE_ENV: test
          AWS_XRAY_LOG_LEVEL: silent
          AWS_XRAY_CONTEXT_MISSING: LOG_ERROR
      - image: redis:latest
        auth:
          username: $DOCKERHUB_USERNAME
          password: $DOCKERHUB_PASSWORD
    steps:
      - checkout
      - install_pnpm
      - run:
          name: run setup.sh
          command: |
            export $(egrep -v '^#' .docker/local.env | xargs -0) && ./.circleci/scripts/setup.sh --hosts
      - run:
          name: run tests
          command: |
            export $(egrep -v '^#' .docker/local.env | xargs -0)
            pnpm run --filter=<< parameters.scope >> test-integrations

  build_image:
    description: Build and/or push docker image to ECR. Runs codebuild if specified ECR does not exist to create it

    parameters:
      aws-access-key-id:
        description: 'AWS access key id environment variable'
        type: string
      aws-region:
        description: 'AWS region value'
        type: string
      aws-secret-access-key:
        description: 'AWS secret access key environment variable'
        type: string
      codebuild-project-name:
        description: 'The CodeBuild project name'
        type: string
        default: ''
      codebuild-project-branch:
        description: 'The git branch to build'
        type: string
        default: ''
      ecr-url:
        description: 'The ecr url'
        type: string
      extra-build-args:
        description: 'Extra flags to pass to docker build. For examples, see https://docs.docker.com/engine/reference/commandline/build'
        type: string
        default: --build-arg GIT_SHA=${CIRCLE_SHA1}
      push:
        description: 'Whether or not to push the code'
        type: boolean
        default: false
      repo-name:
        description: 'The ecr repo name'
        type: string
      tag:
        description: 'The docker tag name'
        type: string
        default: latest,$CIRCLE_SHA1

    executor: aws-cli/default

    steps:
      - checkout
      - aws-cli/setup:
          aws-access-key-id: << parameters.aws-access-key-id >>
          aws-secret-access-key: << parameters.aws-secret-access-key >>
          aws-region: << parameters.aws-region >>
      - run:
          name: Setup common environment variables
          command: |
            { \
              echo 'export AWS_ECR_ACCOUNT_URL="<< parameters.ecr-url >>"'; \
              echo 'export REPO_NAME="<< parameters.repo-name >>"'; \
              echo 'export CODEBUILD_PROJECT_NAME="<< parameters.codebuild-project-name >>"'; \
              echo 'export CODEBUILD_PROJECT_BRANCH="<< parameters.codebuild-project-branch >>"'; \
            } >> "$BASH_ENV"
      - when:
          condition: <<parameters.push>>
          steps:
            - run:
                name: Docker build/push
                command: |
                  #!/bin/bash
                  GET_ECR=$(aws ecr describe-repositories --repository-names "${REPO_NAME}" || true)
                  # If the ECR does not exist, run the code build project to create it
                  if [ -z "$GET_ECR" ]; then
                    echo -e "Starting CodeBuild for ${CODEBUILD_PROJECT_NAME}.\n"
                    BUILD_ID=$(aws codebuild start-build --project-name "${CODEBUILD_PROJECT_NAME}" --environment-variables-override name=GIT_BRANCH,value="${CODEBUILD_PROJECT_BRANCH}" --source-version "${CODEBUILD_PROJECT_BRANCH}" --query 'build.id' --output text)
                    BUILD_STATUS="IN_PROGRESS"

                    # Wait for the CodeBuild to complete.
                    while [ "$BUILD_STATUS" == "IN_PROGRESS" ]; do
                      sleep 10
                      echo "Checking build status"
                      BUILD_STATUS=$(aws codebuild batch-get-builds --ids "$BUILD_ID" --query 'builds[0].buildStatus' --output text)
                      if [ "$BUILD_STATUS" == "IN_PROGRESS" ]; then
                        echo -e "Build is ${BUILD_STATUS}, waiting for build to complete...waiting for 10 seconds before next check...\n"
                      fi
                    done

                    if [ "$BUILD_STATUS" != "SUCCEEDED" ]; then
                      echo "CodeBuild failed to succeed with status ${BUILD_STATUS}"
                      exit 1
                    else
                      echo -e "CodeBuild succeeded\n"
                    fi
                  fi
            - aws-ecr/build-and-push-image:
                checkout: false
                repo: << parameters.repo-name >>
                setup-remote-docker: true
                remote-docker-layer-caching: true
                aws-access-key-id: << parameters.aws-access-key-id >>
                aws-secret-access-key: << parameters.aws-secret-access-key >>
                tag: << parameters.tag >>
                extra-build-args: << parameters.extra-build-args >>
      - unless:
          condition: <<parameters.push>>
          steps:
            - setup_remote_docker:
                docker-layer-caching: true
            - aws-ecr/build-image:
                repo: << parameters.repo-name >>
                tag: << parameters.tag >>
                extra-build-args: << parameters.extra-build-args >>
