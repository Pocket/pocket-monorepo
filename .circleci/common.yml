version: 2.1

orbs:
  aws-cli: circleci/aws-cli@2.0.6
  aws-ecr: circleci/aws-ecr@7.3.0
  aws-code-deploy: circleci/aws-code-deploy@3.0.0
  jq: circleci/jq@2.2.0

# This is an enum that is used within all our jobs and our exit early job.
# As a new "service/deployment" is added you should add to the enum.
# Then each job you pass a "for" to, so that we can determine if this job is for this "commit"
repo_for_enum: &repo_for_enum
  for:
    description: which repo this job is relevant for
    type: enum
    enum: 
      - image_api
      - annotations_api
      - shared_snowplow_consumer
      - parser_graphql_wrapper
      - transactional_emails
      - fxa_webhook_proxy
      - user_api
      - list_api
      - client_api
      - feature_flags
      - sendgrid_data
      - account_data_deleter

resource_class_enmum: &resource_class_enmum
  resource-class:
    description: The self hosted runnner to run on
    type: enum
    enum: 
      - pocket/default-dev
      - pocket/default-prod


parameters:
  image_api:
    type: boolean
    default: false
  annotations_api:
    type: boolean
    default: false
  shared_snowplow_consumer:
    type: boolean
    default: false
  parser_graphql_wrapper:
    type: boolean
    default: false
  transactional_emails:
    type: boolean
    default: false
  fxa_webhook_proxy:
    type: boolean
    default: false
  user_api:
    type: boolean
    default: false
  client_api:
    type: boolean
    default: false
  list_api:
    type: boolean
    default: false
  feature_flags:
    type: boolean
    default: false
  sendgrid_data:
    type: boolean
    default: false
  account_data_deleter:
    type: boolean
    default: false
  
commands:
  # Refrenced from https://github.com/kelvintaywl-cci/dynamic-config-showcase/blob/main/.circleci/next.yml
  exit-early-if-irrelevant:
    parameters:
      <<: *repo_for_enum
    steps:
      - run:
          name: stop early unless relevant
          command: |
            # looks up the relevant pipeline parameter via the env var
            export RELEVANT=$(eval echo "\$<< parameters.for >>")

            # NOTE: env var values are strings (not boolean)
            if [ "${RELEVANT}" = "1" ]; then
              echo "continuing, since job is for << parameters.for >>"
            else
              echo "stopping early!"
              circleci-agent step halt
            fi
          environment:
            image_api: << pipeline.parameters.image_api >>
            annotations_api: << pipeline.parameters.annotations_api >>
            shared_snowplow_consumer: << pipeline.parameters.shared_snowplow_consumer >>
            parser_graphql_wrapper: << pipeline.parameters.parser_graphql_wrapper >>
            transactional_emails: << pipeline.parameters.transactional_emails >>
            fxa_webhook_proxy: << pipeline.parameters.fxa_webhook_proxy >>
            user_api: << pipeline.parameters.user_api >>
            list_api: << pipeline.parameters.list_api >>
            client_api: << pipeline.parameters.client_api >>
            feature_flags: << pipeline.parameters.feature_flags >>
            sendgrid_data: << pipeline.parameters.sendgrid_data >>
            account_data_deleter: << pipeline.parameters.account_data_deleter >>

  install_pnpm:  
    steps:
      - run:
          name: Install pnpm package manager
          command: |
            corepack prepare pnpm@latest-8 --activate
      - run:  
          name: Install Dependencies
          command: |
            pnpm install
  install_infrastructure_pnpm:
    steps:
      - run: 
          name: Install and setup node
          command: |
            . /home/circleci/.codebuild_shims_wrapper.sh
            nvm install
            nvm use
            npm install -g pnpm   
            pnpm install     
  install_codebuild_secrets:
    steps:
      - run: 
          name: Setup our secrets from AWS Secret Manager
          command: |
            . /home/circleci/.codebuild_shims_wrapper.sh
            echo 'export SECRET_VALUE="$(aws secretsmanager get-secret-value --secret-id CodeBuild/Default --query SecretString --output text)"' >> "$BASH_ENV"
            echo 'export TERRAFORM_TOKEN="$(echo $SECRET_VALUE | jq -r '.terraform_token')"' >> "$BASH_ENV"
            echo 'export PAGERDUTY_TOKEN="$(echo $SECRET_VALUE | jq -r '.mozilla_pagerduty_token')"' >> "$BASH_ENV"
            echo 'export GITHUB_ACCESS_TOKEN="$(echo $SECRET_VALUE | jq -r '.github_access_token')"' >> "$BASH_ENV"
            echo 'export GITHUB_TOKEN="$(echo $SECRET_VALUE | jq -r '.github_access_token')"' >> "$BASH_ENV"
      - run:
          name: Save off terraform token
          command: |
            echo Setting Up Terraform Token
            rc="credentials \"app.terraform.io\" { "
            rc="${rc} token=\"$TERRAFORM_TOKEN\" "
            rc="${rc}}"
            echo "$rc" > ~/.terraformrc

jobs:

  infrastructure:
    description: Build and optionally deploy the infratructure
    parameters:
      scope:
        description: The pnpm scope to build for
        type: string
      stack-output-path:
        description: The pnpm output path
        type: string
      apply:
        description: If you should apply
        type: boolean
        default: false
      dev:
        description: Whether or not its a dev build
        type: boolean
        default: false
      workspace:
        description: The terraform workspace
        type: string
      save_app_spec:
        description: Whether or not we should save off the app spec file for later use
        type: boolean
        default: true
      <<: [*repo_for_enum, *resource_class_enmum]
    # Our self hosted runners dont support docker images, cause its not deployed in kubernetes, so we have some special steps
    machine: true
    resource_class: << parameters.resource-class >>
    steps:
      - exit-early-if-irrelevant:
          for: << parameters.for >>
      - checkout
      - restore_cache:
          name: Restore Tfenv
          keys:
            - tfenv-v2
      - run:
          name: Install tfcmt
          command: |
            curl -L https://github.com/suzuki-shunsuke/tfcmt/releases/download/v4.7.3/tfcmt_linux_amd64.tar.gz | tar xvzf - tfcmt
            mv tfcmt /home/circleci/tfcmt
            chmod a+x /home/circleci/tfcmt
      - install_infrastructure_pnpm
      - install_codebuild_secrets
      - when:
          condition: <<parameters.dev>>
          steps:
            - run:
                name: Build Dev Infra
                command: |
                  . /home/circleci/.codebuild_shims_wrapper.sh
                  nvm use
                  export NODE_ENV=development
                  pnpm run --filter=<< parameters.scope >>... build
                  pnpm run --filter=<< parameters.scope >> synth
      - unless:
          condition: <<parameters.dev>>
          steps:
            - run:
                name: Build Prod Infra
                command: |
                  . /home/circleci/.codebuild_shims_wrapper.sh
                  nvm use
                  export NODE_ENV=production
                  pnpm run --filter=<< parameters.scope >>... build
                  pnpm run --filter=<< parameters.scope >> synth
      - run:
          name: Setup terraform
          command: |
            . /home/circleci/.codebuild_shims_wrapper.sh
            cd << parameters.stack-output-path >>
            tfenv use
            terraform init
      - when:
          condition: <<parameters.save_app_spec>>
          steps:
            - restore_cache:
                name: Restore AppSpec Cache
                keys:
                  - appspec-<< parameters.for >>
      - when:
          condition: <<parameters.apply>>
          steps:
            - attach_workspace:
                at: /tmp/workspace
            - run:
                name: Terraform apply
                command: |
                  . /home/circleci/.codebuild_shims_wrapper.sh
                  cd << parameters.stack-output-path >>
                  /home/circleci/tfcmt --var target:<< parameters.scope >><<#parameters.dev>>-dev<</parameters.dev>> apply -- terraform apply -auto-approve -lock-timeout=10m
            - when:
                condition: <<parameters.save_app_spec>>
                steps:
                 - run:
                     name: Copy App Spec
                     command: |
                       . /home/circleci/.codebuild_shims_wrapper.sh
                       cd << parameters.stack-output-path >>
                       mkdir -p /tmp/workspace/<< parameters.for >>
                       cp appspec.json /tmp/workspace/<< parameters.for >>/
                 - persist_to_workspace:
                    root: /tmp/workspace
                    paths:
                      - '<< parameters.for >>/appspec.json'
      - unless:
          condition: <<parameters.apply>>
          steps:
            - run:
                name: Terraform plan
                command: |
                  . /home/circleci/.codebuild_shims_wrapper.sh
                  cd << parameters.stack-output-path >>
                  /home/circleci/tfcmt --var target:<< parameters.scope >><<#parameters.dev>>-dev<</parameters.dev>> plan --skip-no-changes --patch -- terraform plan -lock-timeout=10m
      - save_cache:
          key: tfenv-v2
          paths:
            - /home/circleci/.tfenv/versions/*
            - /home/circleci/.tfenv/bin/terraform-*
      - when:
          condition: <<parameters.save_app_spec>>
          steps:
            - save_cache:
                key: appspec-<< parameters.for >>
                paths:
                  - << parameters.stack-output-path >>/appspec.json
  code_deploy_ecs:
    parameters:
      workspace:
        description: Workspace where the appspec.json are at
        type: string
        default: /tmp/workspace
      codedeploy-app-name:
        description: CodeDeploy app name
        type: string
      codedeploy-group-name:
        description: CodeDeploy group name
        type: string
      <<: [*repo_for_enum, *resource_class_enmum]
    # Our self hosted runners dont support docker images, cause its not deployed in kubernetes, so we have some special steps
    machine: true
    resource_class: << parameters.resource-class >>
    steps:
      - exit-early-if-irrelevant:
          for: << parameters.for >>
      - attach_workspace:
          at: << parameters.workspace >>
      - run:
          name: CodeDeploy
          command: |
            . /home/circleci/.codebuild_shims_wrapper.sh
            export AWS_PAGER=""
            currentDeployment=$(aws deploy list-deployments --application-name "<< parameters.codedeploy-app-name >>" --deployment-group-name "<< parameters.codedeploy-group-name >>" --query "deployments[?status=='InProgress'].deploymentId" --output text --no-cli-pager)
            if [ -n "$currentDeployment" ]; then
              echo "There is already a deployment in progress with ID: $currentDeployment" waiting for it to finish
              aws deploy wait deployment-successful --deployment-id "$deploymentId" --no-cli-pager || {
                echo "Deployment failed or timed out."
                exit 1
              }
            fi

            export appspec=$(cat '<< parameters.workspace >>/<< parameters.for >>/appspec.json')
            export REVISION="revisionType=AppSpecContent,appSpecContent={content='$appspec'}"
            aws deploy \
            create-deployment \
            --application-name="<< parameters.codedeploy-app-name >>"  \
            --deployment-group-name="<< parameters.codedeploy-group-name >>" \
            --description="Triggered from CircleCI" \
            --revision="$REVISION" \
            --no-cli-pager

  code_deploy_lambda:
    parameters:
      codedeploy-app-name:
        description: CodeDeploy app name
        type: string
      codedeploy-group-name:
        description: CodeDeploy group name
        type: string
      function-name:
        description: >
          The name of the Lambda Function to deploy to
        type: string
      s3-bucket:
        type: string
        description: The name of the bucket to deploy from
      s3-key:
        type: string
        description: The name of the s3 key that contains the code to deploy
        default: ""
      function-alias:
        type: string
        description: The name of the lambda alias to use
        default: DEPLOYED
      <<: [*repo_for_enum, *resource_class_enmum]
    # Our self hosted runners dont support docker images, cause its not deployed in kubernetes, so we have some special steps
    machine: true
    resource_class: << parameters.resource-class >>
    steps:
      - exit-early-if-irrelevant:
          for: << parameters.for >>
      - jq/install
      - run:
          name: Deploy Lambda
          command: |
            . /home/circleci/.codebuild_shims_wrapper.sh
            export AWS_PAGER=""
            aws lambda wait function-updated --function-name '<< parameters.function-name >>'

            s3Key="<< parameters.s3-key >>"
            if [[ -z $s3Key ]]; then
                s3Key="$CIRCLE_SHA1.zip"
            fi

            aws lambda update-function-code \
                --function-name '<< parameters.function-name >>' \
                --s3-bucket '<< parameters.s3-bucket >>' \
                --s3-key "$s3Key"

            aws lambda wait function-updated --function-name '<< parameters.function-name >>'

            versionId=$(aws lambda publish-version \
                --function-name '<< parameters.function-name >>' | jq -r .Version)

            currentVersion=$(aws lambda get-alias \
                --function-name '<< parameters.function-name >>' \
                --name DEPLOYED | jq -r .FunctionVersion)

            app_spec_content_string="{'version':0.0,'Resources':[{'<< parameters.function-name >>':{'Type':'AWS::Lambda::Function','Properties':{'Name':'<< parameters.function-name >>','Alias':'<< parameters.function-alias >>','TargetVersion':'$versionId', 'CurrentVersion': '$currentVersion'}}}]}"
            echo "$app_spec_content_string"
            app_spec_content_sha256=$(echo -n "$app_spec_content_string" | shasum -a 256 | sed 's/ .*$//')
            revision="revisionType=AppSpecContent,appSpecContent={content=\"$app_spec_content_string\",sha256=$app_spec_content_sha256}"

            aws lambda wait function-updated --function-name '<< parameters.function-name >>'

            aws deploy create-deployment \
              --application-name="<< parameters.codedeploy-app-name >>" \
              --deployment-group-name="<< parameters.codedeploy-group-name >>" \
              --description="Triggered build $CIRCLE_SHA1 from CircleCI" \
              --revision="$revision"

  test_integrations:
    description: Run integration tests against external services, e.g. MySQL
    parameters:
      scope:
        description: The pnpm scope to run tests for
        type: string
      <<: *repo_for_enum
    docker:
      - image: *node_image
        auth:
          username: $DOCKERHUB_USERNAME
          password: $DOCKERHUB_PASSWORD
        environment:
          AWS_XRAY_LOG_LEVEL: silent
          AWS_XRAY_CONTEXT_MISSING: LOG_ERROR
      - image: redis:latest
        auth:
          username: $DOCKERHUB_USERNAME
          password: $DOCKERHUB_PASSWORD
      - image: mysql:8.0.36
        auth:
          username: $DOCKERHUB_USERNAME
          password: $DOCKERHUB_PASSWORD
        environment:
          - MYSQL_ALLOW_EMPTY_PASSWORD=yes
          - TZ=UTC
        command: --default_authentication_plugin=mysql_native_password --sql-mode="NO_ENGINE_SUBSTITUTION" --character-set-server=UTF8MB3 --collation-server=utf8_unicode_ci
      - image: localstack/localstack:3.0.2
        auth:
          username: $DOCKERHUB_USERNAME
          password: $DOCKERHUB_PASSWORD
        environment:
          SERVICES: s3,kinesis,sqs,dynamodb,sts,events,firehose
      - image: pocket/snowplow-micro:prod
        auth:
          username: $DOCKERHUB_USERNAME
          password: $DOCKERHUB_PASSWORD
    steps:
      - exit-early-if-irrelevant:
          for: << parameters.for >>
      - checkout
      - install_pnpm
      - run:
          name: run setup.sh
          command: |
            export $(egrep -v '^#' .docker/local.env | xargs -0) && ./.circleci/scripts/setup.sh --db --aws
      - run:
          # Note there is a bug in turbo repo requiring a build https://github.com/vercel/turbo/issues/1609
          name: run tests
          command: |
            export $(egrep -v '^#' .docker/local.env | xargs -0)
            pnpm run --filter=<< parameters.scope >>... build
            pnpm run --filter=<< parameters.scope >>... test-integrations

  build_image:
    description: Build and/or push docker image to ECR.

    parameters:
      aws-access-key-id:
        description: 'AWS access key id environment variable'
        type: string
      aws-region:
        description: 'AWS region value'
        type: string
      aws-secret-access-key:
        description: 'AWS secret access key environment variable'
        type: string
      ecr-url:
        description: 'The ecr url'
        type: string
      extra-build-args:
        description: 'Extra flags to pass to docker build. For examples, see https://docs.docker.com/engine/reference/commandline/build'
        type: string
        default: --build-arg GIT_SHA=${CIRCLE_SHA1}
      push:
        description: 'Whether or not to push the code'
        type: boolean
        default: false
      repo-name:
        description: 'The ecr repo name'
        type: string
      tag:
        description: 'The docker tag name'
        type: string
        default: latest,$CIRCLE_SHA1
      app_path:
        description: 'The path needed for building the Docker image'
        type: string
        default: '.'
      layer_caching:
        description: 'Whether to use docker layer caching'
        type: boolean
        default: true
      <<: *repo_for_enum
    executor: aws-cli/default

    steps:
      - exit-early-if-irrelevant:
          for: << parameters.for >>
      - checkout
      - aws-cli/setup:
          aws-access-key-id: << parameters.aws-access-key-id >>
          aws-secret-access-key: << parameters.aws-secret-access-key >>
          aws-region: << parameters.aws-region >>
      - run:
          name: Setup common environment variables
          command: |
            { \
              echo 'export AWS_ECR_ACCOUNT_URL="<< parameters.ecr-url >>"'; \
              echo 'export REPO_NAME="<< parameters.repo-name >>"'; \
            } >> "$BASH_ENV"
      - when:
          condition: <<parameters.push>>
          steps:
            - aws-ecr/build-and-push-image:
                checkout: false
                repo: << parameters.repo-name >>
                path: << parameters.app_path >>
                setup-remote-docker: true
                remote-docker-layer-caching: << parameters.layer_caching >>
                aws-access-key-id: << parameters.aws-access-key-id >>
                aws-secret-access-key: << parameters.aws-secret-access-key >>
                tag: << parameters.tag >>
                remote-docker-version: default
                extra-build-args: << parameters.extra-build-args >>
      - unless:
          condition: <<parameters.push>>
          steps:
            - setup_remote_docker:
                version: default
                docker-layer-caching: << parameters.layer_caching >>
            - aws-ecr/build-image:
                repo: << parameters.repo-name >>
                tag: << parameters.tag >>
                path: << parameters.app_path >>
                extra-build-args: << parameters.extra-build-args >>

  build_lambda:
    description: Build and/or push lambda function.
    parameters:
      aws-access-key-id:
        description: 'AWS access key id environment variable'
        type: string
      aws-region:
        description: 'AWS region value'
        type: string
      aws-secret-access-key:
        description: 'AWS secret access key environment variable'
        type: string
      s3-bucket:
        description: 'The s3 bucket name'
        type: string
        default: ""
      scope:
        description: The pnpm scope to build for
        type: string
      sentry_project_name:
        type: string
        description: the Sentry project name
        default: ""
      sentry_env:
        type: string
        default: Prod
        description: Which environment the release is going to
      sentry_org:
        type: string
        description: The sentry org to upload source maps to
      <<: *repo_for_enum
    docker:
      - image: *node_image
        auth:
          username: $DOCKERHUB_USERNAME
          password: $DOCKERHUB_PASSWORD
    steps:
      - exit-early-if-irrelevant:
          for: << parameters.for >>
      - run:
          name: Setup Environment variables
          command: |
            echo "export SENTRY_AUTH_TOKEN="$SENTRY_BEARER"" >> "$BASH_ENV"
      - checkout
      - install_pnpm
      - run:
          # Theres a really annoying bug in PNPM deploy command that will try and create a folder at /home/pruned which we are not allowed to do, 
          # so we move it under 1 directory to let it do its thing.
          # https://github.com/pnpm/pnpm/issues/5086
          # We also go crazy on the deploy command per https://github.com/pnpm/pnpm/issues/6166#issuecomment-1802541463
          name: Build lambda
          command: |
            pnpm install --filter=<< parameters.scope >>... --frozen-lockfile
            pnpm run --filter=<< parameters.scope >>... build
            mkdir -p ~/bug/project
            cp -R . ~/bug/project/
            cd ~/bug/project/
            pnpm --config.shamefully-hoist=true --config.hoist=true --config.node-linker=true --config.symlinks=false --config.shared-workspace-lockfile=false deploy --filter=<< parameters.scope >> --prod pruned
      - when:
          condition: << parameters.sentry_project_name >>
          steps:
            - run:
                name: Inject Sentry & Upload Sourcemaps
                command: |
                  cd ~/bug/project/
                  pnpx @sentry/cli sourcemaps inject pruned/dist
                  pnpx @sentry/cli sourcemaps upload pruned/dist --release ${CIRCLE_SHA1} --auth-token ${SENTRY_AUTH_TOKEN} --org << parameters.sentry_org >> --project << parameters.sentry_project_name >>
      - run:
          name: Package Lambda
          command: |
            cd ~/bug/project/pruned
            cp -r package.json dist/
            cp -r node_modules/ dist/node_modules/

            cd dist
            zip -r9 ~/project/${CIRCLE_SHA1}.zip .
            mkdir /tmp/artifacts
            cp ~/project/${CIRCLE_SHA1}.zip /tmp/artifacts/
            cd ..
            maxFileSize=256000 # Get the size of the directory in kilobytes
            export dirSize=$(du -s dist | cut -f1) 
            echo "Size is: $dirSize"
            if ((dirSize > maxFileSize)); then
              echo "Directory size is equal to or larger than $maxFileSize KB. which is the lambda limit"
              exit 1
            fi 
      - when:
          condition: << parameters.s3-bucket >>
          steps:
            - aws-cli/setup:
                aws-access-key-id: << parameters.aws-access-key-id >>
                aws-secret-access-key: << parameters.aws-secret-access-key >>
                aws-region: << parameters.aws-region >>
            - run:
                name: Upload Package
                command: aws s3 cp ${CIRCLE_SHA1}.zip s3://<< parameters.s3-bucket >>/ 
      - store_artifacts:
          path: /tmp/artifacts

  apollo:
    description: >
      Runs Apollo rover schema check on the production graphql federated schema.
      If it is the production branch will deploy the subgraph to the production federated graph.
      If the branch is the development branch, will deploy the subgraph to the development federated graph.

    parameters:
      fed_graph_name:
        type: string
        description: The name of federated graph to check
      graph_name:
        type: string
        description: The name of this subgraph
      schema_file_path:
        type: string
        description: The patht to the schema file
        default: ./schema.graphql
      prod_graph_url:
        type: string
        description: The production subgraph url
      dev_graph_url:
        type: string
        description: The development subgraph url
      prod_graph_variant_name:
        type: string
        description: The production variant graph name
        default: "current"
      dev_graph_variant_name:
        type: string
        description: The development variant graph name
        default: "development"
      prod_branch:
        type: string
        description: The production git branch
        default: "main"
      dev_branch:
        type: string
        description: The development git branch
        default: "dev"
      apollo_key_env:
        type: env_var_name
        default: APOLLO_KEY
        description: The environment variable name of the apollo key to user
      build_command:
        description: 'build command to use if we need to'
        type: string
        default: ""

    docker:
      - image: *node_image
        auth:
          username: $DOCKER_LOGIN
          password: $DOCKER_PASSWORD

    steps:
      - checkout
      - run:
          name: install rover
          command: |
            # download and install Rover
            curl -sSL https://rover.apollo.dev/nix/latest | sh

            # This allows the PATH changes to persist to the next `run` step
            echo "export PATH=$HOME/.rover/bin:$PATH" >> "$BASH_ENV"
      - when:
          condition: << parameters.build_command >>
          steps:
            - install_pnpm
            - run:
                name: build schema
                command: |
                  << parameters.build_command >>
      - run:
          name: check service
          command: |
            export APOLLO_KEY=$<< parameters.apollo_key_env >>
            rover subgraph check << parameters.fed_graph_name >>@<< parameters.prod_graph_variant_name >> --schema << parameters.schema_file_path >> --name=<< parameters.graph_name >>
      - when:
          condition:
            equal: [<< parameters.prod_branch >>, << pipeline.git.branch >>]
          steps:
            - run:
                name: push service to prod
                command: |
                  export APOLLO_KEY=$<< parameters.apollo_key_env >>
                  rover subgraph publish << parameters.fed_graph_name >>@<< parameters.prod_graph_variant_name >> --schema << parameters.schema_file_path >> --routing-url << parameters.prod_graph_url >> --name=<< parameters.graph_name >>
      - when:
          condition:
            equal: [<< parameters.dev_branch >>, << pipeline.git.branch >>]
          steps:
            - run:
                name: push service to dev
                command: |
                  export APOLLO_KEY=$<< parameters.apollo_key_env >>
                  rover subgraph publish << parameters.fed_graph_name >>@<< parameters.dev_graph_variant_name >> --schema << parameters.schema_file_path >> --routing-url << parameters.dev_graph_url >> --name=<< parameters.graph_name >>

  sentry_release_notification:
    description: Create new release in Sentry
    resource_class: small
    parameters:
      sentry_project_name:
        type: string
        description: the Sentry project name
      sentry_env:
        type: string
        default: Prod
        description: Which environment the release is going to
      sentry_org:
        type: string
        description: The sentry org
      <<: *repo_for_enum
    docker:
      - image: getsentry/sentry-cli
        auth:
          username: $DOCKER_LOGIN
          password: $DOCKER_PASSWORD
    steps:
      - exit-early-if-irrelevant:
          for: << parameters.for >>
      - run:
          name: Setup Environment variables
          command: |
            echo "export SENTRY_AUTH_TOKEN="$SENTRY_BEARER"" >> "$BASH_ENV"
            echo "export SENTRY_ORG=<< parameters.sentry_org >>" >> "$BASH_ENV"
            echo "export SENTRY_PROJECT=<< parameters.sentry_project_name >>" >> "$BASH_ENV"
      - run:
          name: Sentry Release Notification
          command: |
            source "$BASH_ENV"
            sentry-cli releases new "$CIRCLE_SHA1"
            sentry-cli releases set-commits "$CIRCLE_SHA1" --commit "Pocket/pocket-monorepo@$CIRCLE_SHA1"
            sentry-cli releases finalize "$CIRCLE_SHA1"
      - run:
          name: Sentry Deploy Notification
          command: |
            source "$BASH_ENV"
            sentry-cli releases deploys "$CIRCLE_SHA1" new -e "<< parameters.sentry_env >>"

  setup_deploy_params:
    description: Sets up the CircleCI variables in AWS using the service name and env that is passed
    parameters:
      service_name:
        description: Service Name
        type: string
      env:
        description: Environment of the service
        type: string
      aws_access_key_id:
        type: env_var_name
        default: AWS_ACCESS_KEY_ID
        description: AWS access key id for IAM role
      aws_secret_access_key:
        type: env_var_name
        default: AWS_SECRET_ACCESS_KEY
        description: AWS secret key for IAM role
    docker:
      - image: amazon/aws-cli:latest
        auth:
          username: $DOCKER_LOGIN
          password: $DOCKER_PASSWORD
        environment:
          TERM: xterm

    steps:
      - run:
          name: Put SSM Parameters
          command: |
            export AWS_ACCESS_KEY_ID="${<< parameters.aws_access_key_id >>}"
            export AWS_SECRET_ACCESS_KEY="${<< parameters.aws_secret_access_key >>}"
            aws ssm put-parameter --name "/<< parameters.service_name >>/CircleCI/<< parameters.env >>/BUILD_BRANCH" --type "SecureString" --value "${CIRCLE_BRANCH}" --overwrite
            aws ssm put-parameter --name "/<< parameters.service_name >>/CircleCI/<< parameters.env >>/SERVICE_VERSION" --type "SecureString" --value "${CIRCLE_BUILD_NUM}" --overwrite
            aws ssm put-parameter --name "/<< parameters.service_name >>/CircleCI/<< parameters.env >>/SERVICE_HASH" --type "SecureString" --value "${CIRCLE_SHA1}" --overwrite
